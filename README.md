# liqueur (リキュール)

### Just-in-Time Application Synthesis Framework

**「ソフトウェアの形状を、ユーザーの主観的な現実へと解凍する」**

## 0. 概要

`liqueur` は、ユーザーの自然言語と「感情」を解析し、その瞬間の文脈に最適なアプリケーション構造をリアルタイムに合成するフロントエンドフレームワークです。

私たちが目指すのは、**「完成された製品」としてのソフトウェアの否定**です。ソフトウェアを、ユーザーの意図（Intent）という熱量によって形を変え続ける「液体（Liquid）」へと変貌させ、個々人の複雑なライフスタイルや主観的なロジックに100%適合する体験を提供します。

## 1. 背景：既存のカスタマイズが抱える「二極化の罠」

現代のツールは、ユーザーに対して二つの不誠実な選択を迫っています。

1. **「お絵かき帳」の徒労 (The Notion Problem):**
自由なキャンバスを提供するが、実用的なシステム（家計簿、タスク管理など）を構築するための設計能力と、膨大な手動設定をユーザーに要求する。「使う」ことよりも「作る」ことが目的化してしまう。
2. **「多機能」という名の迷宮 (The Feature Fatigue):**
あらゆるニーズに応えようと設定項目を増やし続けた結果、UIは複雑化し、ユーザーは自分のやりたいことを見つけるだけで疲弊する。

**未来の社会では、ツールが人を理解すべきです。**
ユーザーがドメイン知識（統計学、簿記、データ工学）を持っていなくても、AIがその「橋渡し」となり、最適な道具をその場で作り上げる必要があります。

## 2. 歴史的必然性：インターフェースの進化とプログラミング言語の変遷

インターフェースの進化は、それを出力するプログラミング言語の「抽象化能力」および「安全性の定義」の歴史と密接に同期しています。`liqueur` が提唱する **Adaptive Era (適応型ランタイム)** は、プログラミングと言語学、そしてAIが融合した結果として現れる「歴史の到達点」です。

### Ⅰ. 疎結合の時代 (Web 1.0 - C/Perl)

* **言語とUIの関係:** UIは単なる「文字列 (String)」でした。
* **特徴:** C言語やPerlが標準入出力を通じてHTMLという名の「長い文字列」を吐き出していた時代。プログラムにとってUIの構造はブラックボックスであり、カッコの閉じ忘れなどの構文エラーを防ぐ術はありませんでした。
* **比喩:** ワープロで書いた手紙をそのまま配る。

### Ⅱ. テンプレートの時代 (Web 2.0 - PHP/Ruby/Python)

* **言語とUIの関係:** UIは「動的なテンプレート (Template)」に進化しました。
* **特徴:** スクリプト言語がサーバーサイドで動作し、DBの値をHTMLの変数部分に埋め込む「MVCモデル」が確立。言語がUIの「穴埋め」を制御するようになりましたが、依然としてUIは「最終的に文字列になるもの」という扱いで、実行時の整合性は保証されませんでした。
* **比喩:** 住所氏名だけを書き換える「契約書の雛形」。

### Ⅲ. 型定義された構造の時代 (Modern Web - TypeScript/React)

* **言語とUIの関係:** UIは「型（Type）を持つ木構造 (Virtual DOM)」になりました。
* **特徴:** JSX/TSXの登場により、UIコンポーネントが言語のファーストクラスオブジェクトとなりました。TypeScriptの型システムが、どのコンポーネントに何のデータ（Props）が必要かをコンパイル時に検証。これにより、UIの「壊れにくさ」が劇的に向上しました。
* **限界:** しかし、この構造は依然として `npm run build` 時に決定される **"Solid（固体）"** なものです。一度ビルドされたら、ユーザーがその場でロジック（計算式やデータの解釈）を根本から変更することは不可能です。

### Ⅳ. 意図論的合成の時代 (liqueur Era - LLM × Rust DSL)

* **言語とUIの関係:** UIはユーザーの「意図 (Intent)」を引数とした **「高階関数」** に進化します。
* **特徴:** * **LLM（言語的知能）:** 自然言語という非構造的な要求を、Reinhardt/liqueur が定義した **「Liquid Schema（厳密なDSL）」** へと即座に翻訳（Synthesis）します。
* **Rust（決定論的安全）:** AIが生成した「流動的なスキーマ」を、Rustの型システムが実行時に検証します。AIがいくら自由にUIを合成しても、バックエンドの「物理法則（権限・型・安全）」を逸脱した瞬間にRustがそれを拒絶し、決定論的な安全性を保ちます。


* **歴史的意義:** 開発者が「コード」を書く時代から、AIが「ユーザーのメンタルモデル（主観的な真実）」を解釈し、それをシステムが理解できる「型」へと射影する時代への移行です。

---

### プログラミングと言語学の融合：なぜ「liqueur」なのか？

プログラミング言語が進化するほど、私たちは「コンピュータへの命令（How）」から「目的の記述（What）」へと関心を移してきました。`liqueur` は、その究極である **「ユーザーの意図の表明（Why）」** を、そのままアプリケーションの形状に変換する仕組みを提供します。

1. **文字列 (String)**：構造を持たない、ただの表示。
2. **テンプレート (Template)**：静的な器と、動的なデータの分離。
3. **コンポーネント (Component)**：型による構造の保証。
4. **液体 (Liquid)**：**意図をトリガーとした、構造そのもののJIT（即時）生成。**

この進化は、ソフトウェアを「一度作ったら変えられない鉄の塊」から、ユーザーの思考に追随して形を変える「知的な随伴体」へと昇華させます。家計簿アプリでの「イランリアルの独自レート計算」や「家族カードの別会計ロジック」のような極めて個人的（主観的）なコードは、開発者が書くものではなく、システムがその場で自律的に合成すべきものなのです。

---

**この歴史的視点を加えることで、liqueur が単なる新しいライブラリではなく、Webのパラダイムを一段階押し上げる「歴史的ミッション」を持っていることがより明確になります。**
## 3. 実践的ユースケース：主観に応える「液状化する家計簿」

従来の家計簿アプリでは解決できない、極めてパーソナルな要求を `liqueur` は解決します。

### シナリオ: 既存の枠組みを破壊するパーソナライズ

ユーザーがチャット欄に投げかける言葉が、ダッシュボードの「遺伝子」を書き換えます。

* **ドメインロジックの主観的修正:**
> 「今月はイラン旅行に行った。公式レートは実勢と乖離しすぎているから、私がメモした実効レートで再計算して」
> → AIがLiquid Schemaを介して、そのユーザー専用の**「仮想為替変換レイヤー」**をJIT合成します。


* **文脈によるデータの再定義:**
> 「1月1日から10日までは旅行期間だった。この間のコンビニ支出は食費ではなく全部『旅行費』として扱って」
> → データベースの生データは汚さず、フロントエンドの投影（Projection）レベルで**情報の意味を書き換えます。**


* **複雑な条件分岐の自然言語化:**
> 「高級な買い物は家族カードだから、後で返金される。これらは月間の支出統計から除外して別枠で管理したい」
> → 開発者が想定していない**「別会計」という新しいセクションとロジック**を、その場で生成します。


* **感情に寄り添うデザイン:**
> 「赤色は使いすぎを責められているようで嫌だ。落ち着く青と黒を基調にした画面にして」
> → ユーザーの心理状態をカラーパレットやタイポグラフィに反映し、**「使いたくなる」感情的インターフェース**を構築します。



## 4. liqueur × Reinhardt：自由と統制の融合

この「液状化」は、バックエンドの堅牢な基盤があって初めて安全に機能します。

### Solid Backend (Reinhardt Web)

* **決定論的な防壁:** AIが生成した Liquid Schema は、Rust製のバックエンド（Reinhardt）に送られ、型システムによって厳格に検証されます。
* **プロンプトインジェクションの物理的遮断:** AIが「データベースを全削除する」ようなコードを生成しようとしても、バックエンド側で定義された **Capability（権限）の Enum** に存在しない操作は、論理的に実行不可能です。

### Liquid Frontend (liqueur)

* **JITコンポーネント合成:** Viteの思想を拡張した `Liquid Loader` が、Native ESMを用いて必要なUI部品をミリ秒単位でマウントします。
* **データの射影分離:** 元データ（事実）は不変に保ちつつ、AIが生成した「解釈のフィルタ」を重ね合わせることで、ユーザーごとの「真実」を映し出します。

## 5. あらゆるアプリケーションへの展開

この技術は、家計簿にとどまらず、あらゆるSaaSのあり方を再定義します。

* **コミュニケーション (Slack等):** 「今は集中したい。緊急以外の通知は消して、ただしAプロジェクトの進捗だけは視界の端に1行で出し続けて」
* **証券・投資:** 「私のリスク許容度に合わせて、ポートフォリオの歪みを視覚的に強調する専用ビューを作って」
* **SNS:** 「今日の気分は明るい。批判的な投稿はユーモアのある表現に書き換えて表示するか、見えないようにして」

## 6. 技術的指針： liqueurlization

1. **Intent-to-Schema Engine:** 自然言語と感情を、実行可能なDSL（Liquid Schema）へ変換。
2. **Stateless UI Projection:** UIが作り直されても、スクロール位置や入力中のコンテキストを維持する調停アルゴリズム。
3. **Secure Sandboxing:** ユーザー固有の計算ロジック（例：独自レート計算）を、メインシステムを汚さずにWasmエッジ等で実行。

---

**liqueur は、システムに人間を合わせる時代の終焉を象徴し、一人の人間のために一つのソフトウェアが存在する世界を実現します。**
# liqueur
