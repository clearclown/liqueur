//! Validator Integration Tests
//!
//! Tests Roundtrip serialization and TypeScript specification compatibility

use liquid_protocol::*;
use std::collections::HashMap;

/// Test roundtrip serialization: Rust -> JSON -> Rust
#[test]
fn test_roundtrip_minimal_schema() {
    let original = LiquidViewSchema {
        version: "1.0".to_string(),
        layout: Layout::Grid {
            props: GridLayoutProps {
                columns: 2,
                gap: Some(16),
            },
            children: vec![],
        },
        data_sources: HashMap::new(),
    };

    // Serialize to JSON
    let json = serde_json::to_string(&original).expect("Failed to serialize");

    // Deserialize back
    let deserialized: LiquidViewSchema =
        serde_json::from_str(&json).expect("Failed to deserialize");

    // Should be identical
    assert_eq!(original, deserialized);
}

/// Test roundtrip with complex schema
#[test]
fn test_roundtrip_complex_schema() {
    let mut data_sources = HashMap::new();
    data_sources.insert(
        "sales_data".to_string(),
        DataSource {
            resource: "sales".to_string(),
            filters: Some(vec![Filter {
                field: "status".to_string(),
                op: FilterOperator::Eq,
                value: FilterValue::String("completed".to_string()),
            }]),
            aggregation: Some(Aggregation {
                agg_type: AggregationType::Sum,
                field: "amount".to_string(),
                by: Some("month".to_string()),
            }),
            sort: Some(Sort {
                field: "month".to_string(),
                direction: SortDirection::Asc,
            }),
            limit: Some(12),
        },
    );

    let original = LiquidViewSchema {
        version: "1.0".to_string(),
        layout: Layout::Grid {
            props: GridLayoutProps {
                columns: 2,
                gap: Some(24),
            },
            children: vec![
                Component::Chart {
                    title: Some("Monthly Sales".to_string()),
                    data_source: Some("sales_data".to_string()),
                    variant: ChartVariant::Bar,
                    x_axis: Some("month".to_string()),
                    y_axis: Some("amount".to_string()),
                },
                Component::Table {
                    title: Some("Sales Table".to_string()),
                    data_source: Some("sales_data".to_string()),
                    columns: vec!["month".to_string(), "amount".to_string()],
                    sortable: Some(true),
                },
            ],
        },
        data_sources,
    };

    // Serialize to JSON
    let json = serde_json::to_string(&original).expect("Failed to serialize");

    // Deserialize back
    let deserialized: LiquidViewSchema =
        serde_json::from_str(&json).expect("Failed to deserialize");

    // Should be identical
    assert_eq!(original, deserialized);
}

/// Test TypeScript compatibility: JSON format matching
#[test]
fn test_typescript_json_format_compatibility() {
    // JSON generated by TypeScript implementation
    let typescript_json = r#"{
        "version": "1.0",
        "layout": {
            "type": "grid",
            "props": {
                "columns": 2
            },
            "children": [
                {
                    "type": "chart",
                    "variant": "bar",
                    "title": "Test Chart"
                }
            ]
        },
        "data_sources": {}
    }"#;

    // Should deserialize successfully
    let schema: LiquidViewSchema =
        serde_json::from_str(typescript_json).expect("Failed to parse TypeScript JSON");

    assert_eq!(schema.version, "1.0");
    match schema.layout {
        Layout::Grid { props, children } => {
            assert_eq!(props.columns, 2);
            assert_eq!(children.len(), 1);
        }
        _ => panic!("Expected Grid layout"),
    }
}

/// Test all FilterOperators serialize correctly
#[test]
fn test_filter_operators_serialization() {
    let operators = vec![
        (FilterOperator::Eq, "\"eq\""),
        (FilterOperator::Neq, "\"neq\""),
        (FilterOperator::Gt, "\"gt\""),
        (FilterOperator::Gte, "\"gte\""),
        (FilterOperator::Lt, "\"lt\""),
        (FilterOperator::Lte, "\"lte\""),
        (FilterOperator::In, "\"in\""),
        (FilterOperator::Contains, "\"contains\""),
    ];

    for (op, expected_json) in operators {
        let json = serde_json::to_string(&op).expect("Failed to serialize operator");
        assert_eq!(json, expected_json);
    }
}

/// Test all AggregationTypes serialize correctly
#[test]
fn test_aggregation_types_serialization() {
    let types = vec![
        (AggregationType::Sum, "\"sum\""),
        (AggregationType::Avg, "\"avg\""),
        (AggregationType::Count, "\"count\""),
        (AggregationType::Min, "\"min\""),
        (AggregationType::Max, "\"max\""),
    ];

    for (agg_type, expected_json) in types {
        let json = serde_json::to_string(&agg_type).expect("Failed to serialize type");
        assert_eq!(json, expected_json);
    }
}

/// Test all ChartVariants serialize correctly
#[test]
fn test_chart_variants_serialization() {
    let variants = vec![
        (ChartVariant::Bar, "\"bar\""),
        (ChartVariant::Line, "\"line\""),
        (ChartVariant::Pie, "\"pie\""),
        (ChartVariant::Area, "\"area\""),
    ];

    for (variant, expected_json) in variants {
        let json = serde_json::to_string(&variant).expect("Failed to serialize variant");
        assert_eq!(json, expected_json);
    }
}

/// Test FilterValue variants
#[test]
fn test_filter_value_serialization() {
    // String value
    let value = FilterValue::String("test".to_string());
    let json = serde_json::to_string(&value).unwrap();
    assert_eq!(json, "\"test\"");

    // Number value
    let value = FilterValue::Number(42.5);
    let json = serde_json::to_string(&value).unwrap();
    assert_eq!(json, "42.5");

    // Boolean value
    let value = FilterValue::Boolean(true);
    let json = serde_json::to_string(&value).unwrap();
    assert_eq!(json, "true");

    // Array value
    let value = FilterValue::Array(vec![
        FilterValueScalar::String("a".to_string()),
        FilterValueScalar::Number(1.0),
    ]);
    let json = serde_json::to_string(&value).unwrap();
    assert_eq!(json, "[\"a\",1.0]");
}

/// Test StackLayout serialization
#[test]
fn test_stack_layout_serialization() {
    let layout = Layout::Stack {
        props: StackLayoutProps {
            direction: StackDirection::Horizontal,
            spacing: Some(16),
        },
        children: vec![],
    };

    let json = serde_json::to_value(&layout).expect("Failed to serialize");
    assert_eq!(json["type"], "stack");
    assert_eq!(json["props"]["direction"], "horizontal");
    assert_eq!(json["props"]["spacing"], 16);
}

/// Test Component serialization with data_source
#[test]
fn test_component_with_data_source() {
    let component = Component::Chart {
        title: Some("Sales Chart".to_string()),
        data_source: Some("sales_data".to_string()),
        variant: ChartVariant::Line,
        x_axis: Some("date".to_string()),
        y_axis: Some("revenue".to_string()),
    };

    let json = serde_json::to_value(&component).expect("Failed to serialize");
    assert_eq!(json["type"], "chart");
    assert_eq!(json["variant"], "line");
    assert_eq!(json["data_source"], "sales_data");
    assert_eq!(json["xAxis"], "date");
    assert_eq!(json["yAxis"], "revenue");
}

/// Test DataSource with all fields
#[test]
fn test_data_source_complete() {
    let ds = DataSource {
        resource: "orders".to_string(),
        filters: Some(vec![Filter {
            field: "year".to_string(),
            op: FilterOperator::Eq,
            value: FilterValue::Number(2024.0),
        }]),
        aggregation: Some(Aggregation {
            agg_type: AggregationType::Sum,
            field: "amount".to_string(),
            by: Some("month".to_string()),
        }),
        sort: Some(Sort {
            field: "month".to_string(),
            direction: SortDirection::Asc,
        }),
        limit: Some(10),
    };

    // Roundtrip test
    let json = serde_json::to_string(&ds).expect("Failed to serialize");
    let deserialized: DataSource = serde_json::from_str(&json).expect("Failed to deserialize");
    assert_eq!(ds, deserialized);
}

/// Test validator with valid schema
#[test]
fn test_validator_valid_schema() {
    let mut data_sources = HashMap::new();
    data_sources.insert(
        "test_data".to_string(),
        DataSource {
            resource: "products".to_string(),
            filters: Some(vec![Filter {
                field: "category".to_string(),
                op: FilterOperator::In,
                value: FilterValue::Array(vec![
                    FilterValueScalar::String("electronics".to_string()),
                    FilterValueScalar::String("books".to_string()),
                ]),
            }]),
            aggregation: None,
            sort: None,
            limit: None,
        },
    );

    let schema = LiquidViewSchema {
        version: "1.0".to_string(),
        layout: Layout::Grid {
            props: GridLayoutProps {
                columns: 1,
                gap: None,
            },
            children: vec![Component::Chart {
                title: Some("Product Chart".to_string()),
                data_source: Some("test_data".to_string()),
                variant: ChartVariant::Bar,
                x_axis: None,
                y_axis: None,
            }],
        },
        data_sources,
    };

    let validator = SchemaValidator::new();
    let result = validator.validate(&schema);
    assert!(result.valid, "Expected valid schema, got errors: {:?}", result.errors);
    assert_eq!(result.errors.len(), 0);
}

/// Test validator catches invalid version
#[test]
fn test_validator_invalid_version() {
    let schema = LiquidViewSchema {
        version: "2.0".to_string(),
        layout: Layout::Grid {
            props: GridLayoutProps {
                columns: 1,
                gap: None,
            },
            children: vec![],
        },
        data_sources: HashMap::new(),
    };

    let validator = SchemaValidator::new();
    let result = validator.validate(&schema);
    assert!(!result.valid);
    assert!(matches!(
        result.errors[0],
        ValidationError::UnsupportedVersion(_)
    ));
}

/// Test validator catches dangling references
#[test]
fn test_validator_dangling_reference() {
    let schema = LiquidViewSchema {
        version: "1.0".to_string(),
        layout: Layout::Grid {
            props: GridLayoutProps {
                columns: 1,
                gap: None,
            },
            children: vec![Component::Table {
                title: None,
                data_source: Some("missing_data".to_string()),
                columns: vec!["col1".to_string()],
                sortable: None,
            }],
        },
        data_sources: HashMap::new(),
    };

    let validator = SchemaValidator::new();
    let result = validator.validate(&schema);
    assert!(!result.valid);
    assert!(matches!(
        result.errors[0],
        ValidationError::DanglingDataSourceRef { .. }
    ));
}
